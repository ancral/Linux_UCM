mutex mtx;
condvar prod, cons;
int prod_count=0, cons_count=0;
struct kfifo cbuffer;


int fifoproc_open(bool abre_para_lectura...) { //Ãng
	lock(mtx);
	
	if(abre_para_lectura) { //Consumidor
		cons_count++;
		cond_signal(prod);

		while(prod_count==0) cond_wait(cons,mtx);

	}else{			//Productor
		prod_count++;
		cond_signal(cons);

		while(cons_count==0) cond_wait(prod,mtx);
	}
	return 0;
}


int fifoproc_open(bool abre_para_lectura...) {
	
	/*En el caso de que se produzca un bloqueo, el kernel pone el
	proceso en estado TASK_INTERRUPTIBLE (el proceso
	SÍ responde a señales.). Si el proceso es despertado
	por una señal antes de decrementar el semáforo, la
	función devuelve un valor distinto de 0 y 0 en caso
	contrario.*/
	
	/*if(down_interruptible(&mtx)){
	       return -EINTR;
	}*/
	/*
		Al abrir FIFO en modo lectura (consumidor) se bloquea al proceso
		hasta que productor haya abierto su extremo de escritura
	*/
	if (fich->f_mode & FMODE_READ){
	 // un consumidor abrio el fifo
		
		cons_count++; // aumentamos el nr de consumidores
		
		/*Signal a los productores*/
		lock(&mtx);
		cond_broadcast(prod);
		unlock(&mtx);
		
		lock(&mtx);
		while(prod_count == 0){//Cuando ya no hay productores activos
            cond_wait(nr_cons_waiting == 0,&mtx,); //¿? como pones la condicion? nr_cons_waiting
        );
		unlock(&mtx);
	}
	else{
		//Es un productor
		prod_count++;
		/*Signal a los consumidores*/
		lock(&mtx);
		cond_signal(nr_cons_waiting>0);
		unlock(&mtx);
		
		lock(&mtx);
		while(cons_count == 0){//Cuando ya no hay consumidores activos
            	cond_wait(cons); //¿? como pones la condicion? nr_prod_waiting
        );
		unlock(&mtx);
		
	}	
	//up(mtx); porque el de arriba lo bloquea
}

int fifoproc_write(char* buff, int len...) {
	char kbuffer[MAX_KBUF];
	
	if((*off) > 0) return 0;
	if(len > MAX_CBUFFER_LEN || len > MAX_KBUF) return Error;
	if(copy_from_user(kbuffer,buff,len)) return Error;

	lock(mtx);
	
	//Esperar hasta que haya hueco para insertar (debe haber consumidores)
	while(kfifo_avail(&cbuffer) < len && cons_count > 0) cond_wait(prod,mtx);
	
	//Detectar fin de comunicacion por error (consumidor cierra FIFO antes)
	if (cons_count==0){
		unlock(mtx);
		return -EPIPE;
	}
	
	kfifo_in(&cbuffer, kbuffer, len);
	
	//Despertar a posible consumidor bloqueado
	cond_signal(cons);
	
	unlock(mtx);

	return len;
}

int fifoproc_read(const char* buff, int len...) {
	char kbuf[MAX_KBUF];

	if((*off) > 0) return 0;
	if(len > MAX_CBUFFER_LEN || len > MAX_KBUF) return Error;
        
	lock(mtx);
	
	//Esperar hasta que haya elementos que leer (debe haber productores)
	while(kfifo_len(&cbuffer) < len && prod_count > 0) cond_wait(cons,mtx);
	
	//Detectar fin de comunicacion por error o FIFO vacia
	if(prod_count==0 || kfifo_is_empty(&cbuffer)) {
		unlock(mtx);
		return -EPIPE;
	}
	
	kfifo_out(&cbuffer, kbuf, len);
	
	//Despertar a posible productor bloqueado
	cond_signal(prod);
	
	unlock(mtx);	

	if(copy_to_user(buf,kbuf,len)) return Error;

	return len;
}

void fifoproc_release(bool lectura...) {


}
